#include <format>
#include <fstream>
#include <iostream>
#include <map>
#include <set>
#include <string>

#include "clang/ASTMatchers/ASTMatchFinder.h"
#include "clang/ASTMatchers/ASTMatchers.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "llvm/Support/CommandLine.h"

using namespace llvm;
using namespace clang::tooling;
using namespace clang::ast_matchers;

static cl::OptionCategory ModgenCategory("module_generator options");
static cl::opt<std::string> Name("name",
                                 cl::desc("Name of the resulting C++20 module"),
                                 cl::Required,
                                 cl::cat(ModgenCategory));
static cl::opt<std::string> Output("output",
                                   cl::desc("Path to the module file"),
                                   cl::Required,
                                   cl::cat(ModgenCategory));
static cl::opt<std::string> Filter("regex", cl::desc("Regex to apply"),
                                   cl::Required,
                                   cl::cat(ModgenCategory));
static cl::opt<std::string> Exclude("exclude", cl::desc("Exclude regex"),
                                    cl::Optional,
                                    cl::cat(ModgenCategory));

static DeclarationMatcher GetMatcher() {
    return namedDecl(matchesName(Filter),
                     unless(matchesName(Exclude)),
                     anyOf(unresolvedUsingValueDecl(),
                           varDecl(hasExternalFormalLinkage()),
                           functionDecl(hasExternalFormalLinkage(),
                                        unless(isStaticStorageClass()))
                               .bind("function"),
                           typedefNameDecl(), unresolvedUsingTypenameDecl(),
                           tagDecl(), conceptDecl(), usingDecl(),
                           namespaceDecl(unless(isInline())).bind("namespace")),
                     unless(hasAncestor(tagDecl())),
                     unless(hasAncestor(declaratorDecl())))
        .bind("decl");
}

struct Namespace {
    std::set<std::string> using_names;
};

struct State : public MatchFinder::MatchCallback {
    std::map<std::string, Namespace> names;

    State() {
        names[""];
    }

    void run(const MatchFinder::MatchResult &result) override {
        auto decl = result.Nodes.getNodeAs<clang::NamedDecl>("decl");
        assert(decl != nullptr);
        auto funDecl = result.Nodes.getNodeAs<clang::FunctionDecl>("function");

        auto fqn = decl->getQualifiedNameAsString();
        // Transform FQN into the normal form (no leading or trailing ::)
        if (fqn.starts_with("::")) {
            fqn = fqn.substr(2);
        }
        if (fqn.ends_with("::")) {
            fqn = fqn.substr(0, fqn.size() - 2);
        }

        auto name = decl->getNameAsString();
        auto ns = (fqn == name) ? "" : fqn.substr(0, fqn.size() - 2 - name.size());

        if (decl->getIdentifier() == nullptr) {
            if (funDecl && funDecl->isOverloadedOperator()) {
                // Don't skip an operator overload (e.g. operator<<)
            } else {
                return;
            }
        }

        bool isNamespace =
            result.Nodes.getNodeAs<clang::NamespaceDecl>("namespace");

        if (isNamespace) {
            // Create a Namespace instance to store future names in
            names[fqn];
        } else if (names.contains(ns)) {
            names.at(ns).using_names.insert(name);
        }
    }
};

int main(int argc, const char **argv) {
    auto expected_options =
        CommonOptionsParser::create(argc, argv, ModgenCategory);
    if (!expected_options) {
        errs() << expected_options.takeError();
        return 1;
    }
    auto &options = expected_options.get();

    ClangTool tool{options.getCompilations(), options.getSourcePathList()};
    MatchFinder finder;
    State state;
    auto matcher = GetMatcher();
    finder.addMatcher(matcher, &state);
    int status_code = tool.run(newFrontendActionFactory(&finder).get());
    if (status_code != 0) {
        return status_code;
    }

    std::ofstream mod_file{Output.getValue()};

    mod_file << "// autogenerated\n";
    mod_file << "module;\n\n";
    for (const auto &src : options.getSourcePathList()) {
        std::ifstream source_file{src};
        mod_file << source_file.rdbuf();
    }
    mod_file << std::format("\nexport module {};\n\n", Name.getValue());

    for (const auto &[ns, contents] : state.names) {
        if (ns != "") {
            mod_file << std::format("namespace {} {{\n", ns);
        }

        for (const auto &name : contents.using_names) {
            mod_file << std::format("  export using {}::{};\n", ns, name);
        }

        if (ns != "") {
            mod_file << std::format("}} // namespace {}\n\n", ns);
        }
    }

    return 0;
}
